===== TEST FAIL =====
.................................................................................................F
=================================== FAILURES ===================================
___________________________________ test_098 ___________________________________

    def test_098():
        source = """
    main(){for({1,2}; i * 2; a++ = 2 = 3) {return ;}}
    """
        expected = "Error on line 2 col 16: ;"
>       assert Parser(source).parse() == expected
E       AssertionError: assert 'Error on line 2 col 11: {' == 'Error on line 2 col 16: ;'
E         
E         - Error on line 2 col 16: ;
E         ?                      ^  ^
E         + Error on line 2 col 11: {
E         ?                      ^  ^

test_parser.py:1040: AssertionError
=========================== short test summary info ============================
FAILED test_parser.py::test_098 - AssertionError: assert 'Error on line 2 col...
!!!!!!!!!!!!!!!!!!!!!!!!!! stopping after 1 failures !!!!!!!!!!!!!!!!!!!!!!!!!!!

===== TyC.g4 CONTENT =====
grammar TyC;

@lexer::header {
from lexererr import *
}

@lexer::members {
def emit(self):
    tk = self.type
    if tk == self.UNCLOSE_STRING:
        result = super().emit()
        raise UncloseString(result.text)
    elif tk == self.ILLEGAL_ESCAPE:
        result = super().emit()
        raise IllegalEscape(result.text)
    elif tk == self.ERROR_CHAR:
        result = super().emit()
        raise ErrorToken(result.text)
    else:
        return super().emit()
}

options{
    language=Python3;
}
// =====================
// --- PARSER (refactor, same logic) ---
// =====================

// Program & decls
program: decl* EOF;
decl: structDecl | funcDecl;
// Struct
structDecl: STRUCT ID LBRACE structMemberDecl* RBRACE SEMI;
structMemberDecl: typeSpec ID SEMI;
// Function
funcDecl: typedFuncDecl | inferredFuncDecl;
typedFuncDecl: returnType ID LPAREN paramList? RPAREN blockStmt;
inferredFuncDecl: ID LPAREN paramList? RPAREN blockStmt;
returnType: typeSpec | VOID;
paramList: param (COMMA param)*;
param: typeSpec ID;
// Statements
stmt: varDeclStmt | assignStmt | ifStmt | whileStmt | forStmt | switchStmt
    | breakStmt | continueStmt | returnStmt | exprStmt | blockStmt;
blockStmt: LBRACE stmt* RBRACE;
varDeclStmt: (AUTO | typeSpec) ID (ASSIGN initValue)? SEMI;
assignStmt: assignLHS ASSIGN initValue SEMI;
ifStmt: IF LPAREN expr RPAREN stmt (ELSE stmt)?;
whileStmt: WHILE LPAREN expr RPAREN stmt;
forStmt: FOR LPAREN forInit? SEMI expr? SEMI forUpdateOrClose stmt;
forUpdateOrClose: forUpdate RPAREN | RPAREN;
forInit: varDeclFor | assignFor;
varDeclFor: (AUTO | typeSpec) ID (ASSIGN initValue)?;
assignFor: assignLHS ASSIGN initValue;
forUpdate: assignLHS ASSIGN expr | INC assignLHS | DEC assignLHS | assignLHS INC | assignLHS DEC;
switchStmt: SWITCH LPAREN expr RPAREN LBRACE switchBody RBRACE;
switchBody: caseClause* (defaultClause caseClause*)?;
caseClause: CASE expr COLON stmt*;
defaultClause: DEFAULT COLON stmt*;
breakStmt: BREAK SEMI;
continueStmt: CONTINUE SEMI;
returnStmt: RETURN expr? SEMI;
exprStmt: expr SEMI;
// Types + init
typeSpec: INT | FLOAT | STRING | ID;
initValue: expr | structLiteral;
structLiteral: LBRACE (initValue (COMMA initValue)*)? RBRACE;
// // Expressions (same precedence/logic as your original)
// expr: assignExpr;
// assignExpr: assignLHS ASSIGN assignExpr | logicalOrExpr;
// assignLHS: ID (DOT ID)*;
// logicalOrExpr: logicalAndExpr (OR logicalAndExpr)*;
// logicalAndExpr: equalityExpr (AND equalityExpr)*;
// equalityExpr: relationalExpr ((EQ | NEQ) relationalExpr)*;
// relationalExpr: additiveExpr ((LT | LE | GT | GE) additiveExpr)*;
// additiveExpr: multiplicativeExpr ((PLUS | MINUS) multiplicativeExpr)*;
// multiplicativeExpr: unaryExpr ((MUL | DIV | MOD) unaryExpr)*;
// unaryExpr: prefixIncDecExpr | (NOT | PLUS | MINUS) unaryExpr | primaryExpr;
// incDecTarget: assignLHS | atom;
// prefixIncDecExpr: (INC | DEC)+ incDecTarget (INC | DEC)*;
// atom: funcCallExpr | literal | structLiteral | LPAREN expr RPAREN;
// funcCallExpr: ID LPAREN argList? RPAREN;
// postfixCore: ID (DOT ID)*;
// postfixExpr: postfixCore (INC | DEC)+ | atom (INC | DEC)+;
// primaryExpr: postfixExpr | postfixCore | atom;
// argList: expr (COMMA expr)*;
// literal: INT_LIT | FLOAT_LIT | STRING_LIT;
// Expressions (same precedence/logic as your original)
expr: assignExpr;

assignExpr: assignLHS ASSIGN assignExpr | logicalOrExpr;
assignLHS: ID (DOT ID)*;

logicalOrExpr: logicalAndExpr (OR logicalAndExpr)*;
logicalAndExpr: equalityExpr (AND equalityExpr)*;
equalityExpr: relationalExpr ((EQ | NEQ) relationalExpr)*;
relationalExpr: additiveExpr ((LT | LE | GT | GE) additiveExpr)*;
additiveExpr: multiplicativeExpr ((PLUS | MINUS) multiplicativeExpr)*;
multiplicativeExpr: unaryExpr ((MUL | DIV | MOD) unaryExpr)*;

unaryExpr: prefixIncDecExpr | (NOT | PLUS | MINUS) unaryExpr | primaryExpr;

incDecTarget: assignLHS | atom;
prefixIncDecExpr: (INC | DEC)+ incDecTarget (INC | DEC)*;

// ✅ atom thêm ID
atom: funcCallExpr | literal | structLiteral | ID | LPAREN expr RPAREN;
funcCallExpr: ID LPAREN argList? RPAREN;

// ✅ postfix chuẩn: atom + (.ID | ++ | --)*
postfixExpr: atom postfixOp*;

postfixOp
    : DOT ID
    | INC
    | DEC
    ;

primaryExpr: postfixExpr;

argList: expr (COMMA expr)*;
literal: INT_LIT | FLOAT_LIT | STRING_LIT;


// // =====================
// // --- PARSER ---
// // =====================

// // Program = list decls then EOF
// program
//     : decl* EOF
//     ;

// decl
//     : structDecl
//     | funcDecl
//     ;

// // ---------- Struct ----------
// structDecl
//     : STRUCT ID LBRACE structMemberDecl* RBRACE SEMI
//     ;

// structMemberDecl
//     : typeSpec ID SEMI
//     ;

// // ---------- Function ----------
// // Return type có thể thiếu để inference
// funcDecl
//     : typedFuncDecl
//     | inferredFuncDecl
//     ;

// typedFuncDecl
//     : returnType ID LPAREN paramList? RPAREN blockStmt
//     ;

// inferredFuncDecl
//     : ID LPAREN paramList? RPAREN blockStmt
//     ;

// // returnType
// //     : typeSpec
// //     | VOID
// //     ;
// returnType
//     : typeSpec
//     | VOID
//     // | AUTO
//     ;


// paramList
//     : param (COMMA param)*
//     ;

// param
//     : typeSpec ID
//     ;

// // ---------- Statements ----------
// stmt
//     : varDeclStmt
//     | assignStmt
//     | ifStmt
//     | whileStmt
//     | forStmt
//     | switchStmt
//     | breakStmt
//     | continueStmt
//     | returnStmt
//     | exprStmt
//     | blockStmt
//     ;

// blockStmt
//     : LBRACE stmt* RBRACE
//     ;

// varDeclStmt
//     : AUTO ID (ASSIGN initValue)? SEMI
//     | typeSpec ID (ASSIGN initValue)? SEMI
//     ;

// // assignment statement (LHS bị giới hạn)
// assignStmt
//     : assignLHS ASSIGN initValue SEMI
//     ;

// ifStmt
//     : IF LPAREN expr RPAREN stmt (ELSE stmt)?
//     ;

// whileStmt
//     : WHILE LPAREN expr RPAREN stmt
//     ;

// // forStmt
// //     : FOR LPAREN forInit? SEMI expr? SEMI forUpdate? RPAREN stmt
// //     ;
// // forStmt
// //     : FOR LPAREN forInit? SEMI expr? SEMI (forUpdate)? RPAREN stmt
// //     ;
// forStmt
//     : FOR LPAREN forInit? SEMI expr? SEMI forUpdateOrClose stmt
//     ;

// forUpdateOrClose
//     : forUpdate RPAREN
//     | RPAREN
//     ;

// forInit
//     : varDeclFor
//     | assignFor
//     ;

// varDeclFor
//     : AUTO ID (ASSIGN initValue)?
//     | typeSpec ID (ASSIGN initValue)?
//     ;

// assignFor
//     : assignLHS ASSIGN initValue
//     ;

// // forUpdate
// //     : (PLUS | MINUS)? assignLHS ASSIGN expr
// //     | INC assignLHS
// //     | DEC assignLHS
// //     | assignLHS INC
// //     | assignLHS DEC
// //     ;

// forUpdate
//     : assignLHS ASSIGN expr
//     | INC assignLHS
//     | DEC assignLHS
//     | assignLHS INC
//     | assignLHS DEC
//     ;

// // unaryUpdate
// //     : INC assignLHS
// //     | DEC assignLHS
// //     | assignLHS INC
// //     | assignLHS DEC
// //     ;

// // switchStmt
// //     : SWITCH LPAREN expr RPAREN LBRACE switchClause* RBRACE
// //     ;
// // switchStmt
// //     : SWITCH LPAREN expr RPAREN LBRACE caseClause* defaultClause? RBRACE
// //     ;

// // switchStmt
// //     : SWITCH LPAREN expr RPAREN LBRACE switchClause* RBRACE
// //     ;

// // switchClause
// //     : caseClause
// //     | defaultClause
// //     ;

// switchStmt
//     : SWITCH LPAREN expr RPAREN LBRACE switchBody RBRACE
//     ;
// switchBody
//     : caseClause* (defaultClause caseClause*)?
//     ;
// caseClause
//     : CASE expr COLON stmt*
//     ;

// defaultClause
//     : DEFAULT COLON stmt*
//     ;

// breakStmt
//     : BREAK SEMI
//     ;

// continueStmt
//     : CONTINUE SEMI
//     ;

// // return expr? ;
// returnStmt
//     : RETURN expr? SEMI
//     ;

// exprStmt
//     : expr SEMI
//     ;

// // ---------- Types ----------
// typeSpec
//     : INT
//     | FLOAT
//     | STRING
//     | ID            // struct type name
//     ;

// // initValue dùng cho khai báo/gán: expr hoặc struct literal
// initValue
//     : expr
//     | structLiteral
//     ;

// // Cho phép { expr, expr, ... } hoặc {}
// structLiteral
//     : LBRACE (initValue (COMMA initValue)*)? RBRACE
//     ;

// // =====================
// // ----- EXPRESSIONS ----
// // =====================

// expr
//     : assignExpr
//     ;

// // assignment expression: right-associative
// // Cho phép 1 = 2 = 3 theo testcase
// // assignExpr
// //     : logicalOrExpr (ASSIGN assignExpr)?
// //     ;
// assignExpr
//     : assignLHS ASSIGN assignExpr   // right-associative: x = y = 1
//     | logicalOrExpr
//     ;


// // LHS hợp lệ cho assignment statement + prefix ++/-- target (member access OK)
// assignLHS
//     : ID (DOT ID)*
//     ;

// // OR
// logicalOrExpr
//     : logicalAndExpr (OR logicalAndExpr)*
//     ;

// // AND
// logicalAndExpr
//     : equalityExpr (AND equalityExpr)*
//     ;

// // == !=
// equalityExpr
//     : relationalExpr ((EQ | NEQ) relationalExpr)*
//     ;

// // < <= > >=
// relationalExpr
//     : additiveExpr ((LT | LE | GT | GE) additiveExpr)*
//     ;

// // + -
// additiveExpr
//     : multiplicativeExpr ((PLUS | MINUS) multiplicativeExpr)*
//     ;

// // * / %
// multiplicativeExpr
//     : unaryExpr ((MUL | DIV | MOD) unaryExpr)*
//     ;

// // unary: prefix ++/-- cho phép chuỗi, target là LHS hoặc (expr)
// // và có thể kèm postfix ++/-- ngay sau target (để pass test_022)
// unaryExpr
//     : prefixIncDecExpr
//     | (NOT | PLUS | MINUS) unaryExpr
//     | primaryExpr
//     ;

// incDecTarget
//     : assignLHS
//     | atom 
//     ;

// // Ví dụ hợp lệ theo test: ++--++a, !++a, ++(+a), ++--++--a++--++--
// prefixIncDecExpr
//     : (INC | DEC)+ incDecTarget (INC | DEC)*
//     ;
// atom
//     : funcCallExpr
//     | literal
//     | structLiteral
//     | LPAREN expr RPAREN
//     ;
// funcCallExpr
//     : ID LPAREN argList? RPAREN
//     ;

// postfixCore
//     : ID (DOT ID)*
//     ;

// postfixExpr
//     : postfixCore (INC | DEC)+   // a++, a.b++
//     | atom       (INC | DEC)+    // "s"++, (a+b)++, foo()++
//     ;
// primaryExpr
//     : postfixExpr
//     | postfixCore
//     | atom
//     ;

// argList
//     : expr (COMMA expr)*
//     ;

// literal
//     : INT_LIT
//     | FLOAT_LIT
//     | STRING_LIT
//     ;

// =====================
// --- LEXER ---
// =====================

// ---- Keywords ----
AUTO      : 'auto';
BREAK     : 'break';
CASE      : 'case';
CONTINUE  : 'continue';
DEFAULT   : 'default';
ELSE      : 'else';
FLOAT     : 'float';
FOR       : 'for';
IF        : 'if';
INT       : 'int';
RETURN    : 'return';
STRING    : 'string';
STRUCT    : 'struct';
SWITCH    : 'switch';
VOID      : 'void';
WHILE     : 'while';

// =====================
// Operators (đặt dài trước ngắn)
// =====================
EQ        : '==';
NEQ       : '!=';
LE        : '<=';
GE        : '>=';

OR        : '||';
AND       : '&&';

INC       : '++';
DEC       : '--';

// ---- SPECIAL: "-." must be ONE token per testcase ----
// "-." chỉ là 1 token khi sau '.' KHÔNG phải digit và KHÔNG phải e/E
MINUS_DOT_LIT
    : '-.' { 
        la = self._input.LA(1)
        la != ord('e') and la != ord('E') and (la < ord('0') or la > ord('9'))
      }?
    ;


PLUS      : '+';
MINUS     : '-';
MUL       : '*';
DIV       : '/';
MOD       : '%';

LT        : '<';
GT        : '>';

NOT       : '!';

ASSIGN    : '=';

DOT       : '.';

// ---- Separators ----
// LBRACK    : '[';
// RBRACK    : ']';
LBRACE    : '{';
RBRACE    : '}';
LPAREN    : '(';
RPAREN    : ')';
SEMI      : ';';
COMMA     : ',';
COLON     : ':';

// =====================
// Literals
// =====================

// ---- Float literal ----
FLOAT_LIT
    :  (
          DIGIT+ '.' DIGIT* EXP?     // 1. , 1.0 , 12.34 , 12.e3
        | '.' DIGIT+ EXP?            // .5 , .010e-0
        // | '.' EXP                    // .e-2
        | DIGIT+ EXP                 // 10e-3
      )
    ;

// ---- Integer literal ----
INT_LIT
    :  DIGIT+
    ;

fragment EXP
    : [eE] [+-]? DIGIT+
    ;

fragment DIGIT
    : [0-9]
    ;

// ---- String literal OK ----
STRING_LIT
    : '"' (STR_CHAR | ESC_SEQ)* '"'
      { self.text = self.text[1:-1] }
    ;

// ---- Illegal escape ----
// ILLEGAL_ESCAPE
//     : '"' (STR_CHAR | ESC_SEQ)* '\\' ~[bfrnt"\\]
//       { self.text = self.text[1:] }
//     ;
// ILLEGAL_ESCAPE
//     : '"' (STR_CHAR | ESC_SEQ)* '\\' ~[bfrnt"\\\r\n]
//       { self.text = self.text[1:] }
//     ;
ILLEGAL_ESCAPE
    : '"' (STR_CHAR | ESC_SEQ)* '\\' ( ~[bfrnt"\\] | '\r' | '\n' )
      { self.text = self.text[1:] }
    ;


// ---- Unclosed string ----
UNCLOSE_STRING
    : '"' (STR_CHAR | ESC_SEQ)* ( '\r'? '\n' | EOF )
      { self.text = self.text[1:] }
    ;

fragment STR_CHAR
    : ~["\\\r\n]
    ;

fragment ESC_SEQ
    : '\\' [bfrnt"\\]
    ;

// =====================
// Identifiers
// =====================
ID
    : [_a-zA-Z] [_a-zA-Z0-9]*
    ;

// =====================
// Comments + WS
// =====================
LINE_COMMENT
    : '//' ~[\r\n]* -> skip
    ;

BLOCK_COMMENT
    : '/*' .*? '*/' -> skip
    ;

WS
    : [ \t\f\r\n]+ -> skip
    ;

// =====================
// ERROR
// =====================
ERROR_CHAR
    : .
    ;
