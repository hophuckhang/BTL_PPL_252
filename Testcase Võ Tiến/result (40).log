===== TEST FAIL =====
.....................................................................................................F
=================================== FAILURES ===================================
___________________________________ test_102 ___________________________________

    def test_102():
        source = """
    auto main(){}
    """
        expected = "Error on line 2 col 0: auto"
>       assert Parser(source).parse() == expected
E       AssertionError: assert 'success' == 'Error on line 2 col 0: auto'
E         
E         - Error on line 2 col 0: auto
E         + success

test_parser.py:1086: AssertionError
=========================== short test summary info ============================
FAILED test_parser.py::test_102 - AssertionError: assert 'success' == 'Error ...
!!!!!!!!!!!!!!!!!!!!!!!!!! stopping after 1 failures !!!!!!!!!!!!!!!!!!!!!!!!!!!

===== TyC.g4 CONTENT =====
grammar TyC;

@lexer::header {
from lexererr import *
}

@lexer::members {
def emit(self):
    tk = self.type
    if tk == self.UNCLOSE_STRING:
        result = super().emit()
        raise UncloseString(result.text)
    elif tk == self.ILLEGAL_ESCAPE:
        result = super().emit()
        raise IllegalEscape(result.text)
    elif tk == self.ERROR_CHAR:
        result = super().emit()
        raise ErrorToken(result.text)
    else:
        return super().emit()
}

options{
    language=Python3;
}

// =====================
// --- PARSER ---
// =====================

// Program = list decls then EOF
program
    : decl* EOF
    ;

decl
    : structDecl
    | funcDecl
    ;

// ---------- Struct ----------
structDecl
    : STRUCT ID LBRACE structMemberDecl* RBRACE SEMI
    ;

structMemberDecl
    : typeSpec ID SEMI
    ;

// ---------- Function ----------
// Return type có thể thiếu để inference
funcDecl
    : typedFuncDecl
    | inferredFuncDecl
    ;

typedFuncDecl
    : returnType ID LPAREN paramList? RPAREN blockStmt
    ;

inferredFuncDecl
    : ID LPAREN paramList? RPAREN blockStmt
    ;

// returnType
//     : typeSpec
//     | VOID
//     ;
returnType
    : typeSpec
    | VOID
    | AUTO
    ;


paramList
    : param (COMMA param)*
    ;

param
    : typeSpec ID
    ;

// ---------- Statements ----------
stmt
    : varDeclStmt
    | assignStmt
    | ifStmt
    | whileStmt
    | forStmt
    | switchStmt
    | breakStmt
    | continueStmt
    | returnStmt
    | exprStmt
    | blockStmt
    ;

blockStmt
    : LBRACE stmt* RBRACE
    ;

varDeclStmt
    : AUTO ID (ASSIGN initValue)? SEMI
    | typeSpec ID (ASSIGN initValue)? SEMI
    ;

// assignment statement (LHS bị giới hạn)
assignStmt
    : assignLHS ASSIGN initValue SEMI
    ;

ifStmt
    : IF LPAREN expr RPAREN stmt (ELSE stmt)?
    ;

whileStmt
    : WHILE LPAREN expr RPAREN stmt
    ;

// forStmt
//     : FOR LPAREN forInit? SEMI expr? SEMI forUpdate? RPAREN stmt
//     ;
// forStmt
//     : FOR LPAREN forInit? SEMI expr? SEMI (forUpdate)? RPAREN stmt
//     ;
forStmt
    : FOR LPAREN forInit? SEMI expr? SEMI forUpdateOrClose stmt
    ;

forUpdateOrClose
    : forUpdate RPAREN
    | RPAREN
    ;

forInit
    : varDeclFor
    | assignFor
    ;

varDeclFor
    : AUTO ID (ASSIGN initValue)?
    | typeSpec ID (ASSIGN initValue)?
    ;

assignFor
    : assignLHS ASSIGN initValue
    ;

// forUpdate
//     : (PLUS | MINUS)? assignLHS ASSIGN expr
//     | INC assignLHS
//     | DEC assignLHS
//     | assignLHS INC
//     | assignLHS DEC
//     ;

forUpdate
    : assignLHS ASSIGN expr
    | INC assignLHS
    | DEC assignLHS
    | assignLHS INC
    | assignLHS DEC
    ;

// unaryUpdate
//     : INC assignLHS
//     | DEC assignLHS
//     | assignLHS INC
//     | assignLHS DEC
//     ;

// switchStmt
//     : SWITCH LPAREN expr RPAREN LBRACE switchClause* RBRACE
//     ;
// switchStmt
//     : SWITCH LPAREN expr RPAREN LBRACE caseClause* defaultClause? RBRACE
//     ;

switchStmt
    : SWITCH LPAREN expr RPAREN LBRACE switchClause* RBRACE
    ;

switchClause
    : caseClause
    | defaultClause
    ;

// caseClause
//     : CASE INT_LIT COLON stmt*
//     ;
caseClause
    : CASE expr COLON stmt*
    ;

defaultClause
    : DEFAULT COLON stmt*
    ;

breakStmt
    : BREAK SEMI
    ;

continueStmt
    : CONTINUE SEMI
    ;

// return expr? ;
returnStmt
    : RETURN expr? SEMI
    ;

exprStmt
    : expr SEMI
    ;

// ---------- Types ----------
typeSpec
    : INT
    | FLOAT
    | STRING
    | ID            // struct type name
    ;

// initValue dùng cho khai báo/gán: expr hoặc struct literal
initValue
    : expr
    | structLiteral
    ;

// Cho phép { expr, expr, ... } hoặc {}
structLiteral
    : LBRACE (initValue (COMMA initValue)*)? RBRACE
    ;

// =====================
// ----- EXPRESSIONS ----
// =====================

expr
    : assignExpr
    ;

// assignment expression: right-associative
// Cho phép 1 = 2 = 3 theo testcase
// assignExpr
//     : logicalOrExpr (ASSIGN assignExpr)?
//     ;
assignExpr
    : assignLHS ASSIGN assignExpr   // right-associative: x = y = 1
    | logicalOrExpr
    ;


// LHS hợp lệ cho assignment statement + prefix ++/-- target (member access OK)
assignLHS
    : ID (DOT ID)*
    ;

// OR
logicalOrExpr
    : logicalAndExpr (OR logicalAndExpr)*
    ;

// AND
logicalAndExpr
    : equalityExpr (AND equalityExpr)*
    ;

// == !=
equalityExpr
    : relationalExpr ((EQ | NEQ) relationalExpr)*
    ;

// < <= > >=
relationalExpr
    : additiveExpr ((LT | LE | GT | GE) additiveExpr)*
    ;

// + -
additiveExpr
    : multiplicativeExpr ((PLUS | MINUS) multiplicativeExpr)*
    ;

// * / %
multiplicativeExpr
    : unaryExpr ((MUL | DIV | MOD) unaryExpr)*
    ;

// unary: prefix ++/-- cho phép chuỗi, target là LHS hoặc (expr)
// và có thể kèm postfix ++/-- ngay sau target (để pass test_022)
unaryExpr
    : prefixIncDecExpr
    | (NOT | PLUS | MINUS) unaryExpr
    | primaryExpr
    ;

incDecTarget
    : assignLHS
    | atom 
    ;

// Ví dụ hợp lệ theo test: ++--++a, !++a, ++(+a), ++--++--a++--++--
prefixIncDecExpr
    : (INC | DEC)+ incDecTarget (INC | DEC)*
    ;

// ---------- Primary / Postfix / Member-access ----------
// Atom: call chỉ được phép trên ID: foo(...)
// atom
//     : funcCallExpr
//     | ID
//     | literal
//     | structLiteral
//     | LPAREN expr RPAREN
//     ;
atom
    : funcCallExpr
    | literal
    | structLiteral
    | LPAREN expr RPAREN
    ;


funcCallExpr
    : ID LPAREN argList? RPAREN
    ;

// Postfix core: atom có thể nối .field.field...
// => cho phép foo().a.b
// postfixCore
//     : atom (DOT ID)*
//     ;
postfixCore
    : ID (DOT ID)*
    ;

// Postfix ++/--: chỉ cho phép trên atom (KHÔNG cho trên member access)
// => "s"++ OK
// => a++--++-- OK
// => a.b++ sẽ lỗi tại ++ (đúng test_029)
// postfixExpr
//     : postfixCore (INC | DEC)+
//     ;
postfixExpr
    : postfixCore (INC | DEC)+   // a++, a.b++
    | atom       (INC | DEC)+    // "s"++, (a+b)++, foo()++
    ;



// primaryExpr: ưu tiên postfix ++/-- trước, rồi mới member-access chain
// primaryExpr
//     : postfixExpr
//     | postfixCore
//     ;
primaryExpr
    : postfixExpr
    | postfixCore
    | atom
    ;

argList
    : expr (COMMA expr)*
    ;

literal
    : INT_LIT
    | FLOAT_LIT
    | STRING_LIT
    ;

// =====================
// --- LEXER ---
// =====================

// ---- Keywords ----
AUTO      : 'auto';
BREAK     : 'break';
CASE      : 'case';
CONTINUE  : 'continue';
DEFAULT   : 'default';
ELSE      : 'else';
FLOAT     : 'float';
FOR       : 'for';
IF        : 'if';
INT       : 'int';
RETURN    : 'return';
STRING    : 'string';
STRUCT    : 'struct';
SWITCH    : 'switch';
VOID      : 'void';
WHILE     : 'while';

// =====================
// Operators (đặt dài trước ngắn)
// =====================
EQ        : '==';
NEQ       : '!=';
LE        : '<=';
GE        : '>=';

OR        : '||';
AND       : '&&';

INC       : '++';
DEC       : '--';

// ---- SPECIAL: "-." must be ONE token per testcase ----
// "-." chỉ là 1 token khi sau '.' KHÔNG phải digit và KHÔNG phải e/E
MINUS_DOT_LIT
    : '-.' { 
        la = self._input.LA(1)
        la != ord('e') and la != ord('E') and (la < ord('0') or la > ord('9'))
      }?
    ;


PLUS      : '+';
MINUS     : '-';
MUL       : '*';
DIV       : '/';
MOD       : '%';

LT        : '<';
GT        : '>';

NOT       : '!';

ASSIGN    : '=';

DOT       : '.';

// ---- Separators ----
// LBRACK    : '[';
// RBRACK    : ']';
LBRACE    : '{';
RBRACE    : '}';
LPAREN    : '(';
RPAREN    : ')';
SEMI      : ';';
COMMA     : ',';
COLON     : ':';

// =====================
// Literals
// =====================

// ---- Float literal ----
FLOAT_LIT
    :  (
          DIGIT+ '.' DIGIT* EXP?     // 1. , 1.0 , 12.34 , 12.e3
        | '.' DIGIT+ EXP?            // .5 , .010e-0
        // | '.' EXP                    // .e-2
        | DIGIT+ EXP                 // 10e-3
      )
    ;

// ---- Integer literal ----
INT_LIT
    :  DIGIT+
    ;

fragment EXP
    : [eE] [+-]? DIGIT+
    ;

fragment DIGIT
    : [0-9]
    ;

// ---- String literal OK ----
STRING_LIT
    : '"' (STR_CHAR | ESC_SEQ)* '"'
      { self.text = self.text[1:-1] }
    ;

// ---- Illegal escape ----
// ILLEGAL_ESCAPE
//     : '"' (STR_CHAR | ESC_SEQ)* '\\' ~[bfrnt"\\]
//       { self.text = self.text[1:] }
//     ;
ILLEGAL_ESCAPE
    : '"' (STR_CHAR | ESC_SEQ)* '\\' ~[bfrnt"\\\r\n]
      { self.text = self.text[1:] }
    ;

// ---- Unclosed string ----
UNCLOSE_STRING
    : '"' (STR_CHAR | ESC_SEQ)* ( '\r'? '\n' | EOF )
      { self.text = self.text[1:] }
    ;

fragment STR_CHAR
    : ~["\\\r\n]
    ;

fragment ESC_SEQ
    : '\\' [bfrnt"\\]
    ;

// =====================
// Identifiers
// =====================
ID
    : [_a-zA-Z] [_a-zA-Z0-9]*
    ;

// =====================
// Comments + WS
// =====================
LINE_COMMENT
    : '//' ~[\r\n]* -> skip
    ;

BLOCK_COMMENT
    : '/*' .*? '*/' -> skip
    ;

WS
    : [ \t\f\r\n]+ -> skip
    ;

// =====================
// ERROR
// =====================
ERROR_CHAR
    : .
    ;
